<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fragmented Coastline Prediction</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>ðŸŒŠ Fragmented Coastline Prediction</h1>
            <p>Interactive visualization of historical and predicted coastline data</p>
        </header>

        <div class="controls-panel">
            <div class="time-controls">
                <label for="year-slider">Year: <span id="current-year">2025</span></label>
                <input type="range" id="year-slider" min="1984" max="2100" value="2025" class="slider">
                <div class="year-labels">
                    <span>1984</span>
                    <span>2100</span>
                </div>
            </div>
            
            <div class="data-info">
                <div class="info-item">
                    <span class="label">Data Type:</span>
                    <span id="data-type" class="value">Historical</span>
                </div>
                <div class="info-item">
                    <span class="label">Data Points:</span>
                    <span id="data-count" class="value">0</span>
                </div>
                <div class="info-item">
                    <span class="label">View Area:</span>
                    <span id="view-area" class="value">Global</span>
                </div>
            </div>

            <div class="map-controls">
                <button id="reset-zoom" class="btn">Reset View</button>
                <button id="animate-btn" class="btn">Animate</button>
                <button id="toggle-contours" class="btn active">Show Contours</button>
                <button id="toggle-points" class="btn">Show Points</button>
            </div>
        </div>

        <div class="map-container">
            <div id="map"></div>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Loading data...</p>
            </div>
        </div>

    </div>

    <script>
        // Global variables
        let map;
        let currentYear = 2025;
        let currentBounds = null;
        let contourLayers = [];
        let pointLayers = [];
        let showContours = true;
        let showPoints = false;
        let isAnimating = false;
        let animationInterval = null;
        let animationSpeed = 750; // milliseconds between frames
        let animationDelay = 1500; // milliseconds before starting animation
        let currentData = null; // Store current data for toggling
        let url, params; // Store url and params for data points
        
        // slow, normal, fast
        // animation speed : slow = 1000, normal = 700, fast = 500
        // animation delay : slow = 2500, normal = 1500, fast = 500

        // Initialize map
        function initMap() {
            console.log('Initializing map...');
            
            try {
                map = L.map('map').setView([27.7663, -82.6404], 6);
                console.log('Map created successfully');
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Â© OpenStreetMap contributors'
                }).addTo(map);
                console.log('Tile layer added');

                // Listen for map move events to update bounds
                map.on('moveend', function() {
                    updateBounds();
                });

                // Hide loading indicator
                showLoading(false);
                console.log('Map initialization complete');

                // Load initial data
                loadDataForYear(currentYear);
            } catch (error) {
                console.error('Error initializing map:', error);
                showLoading(false);
            }
        }

        // Update bounds when map view changes
        function updateBounds() {
            const bounds = map.getBounds();
            // Store bounds as [min latitude, min longitude, max latitude, max longitude]
            currentBounds = [
                bounds.getSouth(), // min latitude
                bounds.getWest(), // min longitude
                bounds.getNorth(), // max latitude
                bounds.getEast() // max longitude
            ];
            
            // Update view area display
            const area = calculateArea(currentBounds);
            document.getElementById('view-area').textContent = 
                area > 1000000 ? 'Global' : 
                area > 100000 ? 'Regional' : 'Local';
            
            // Reload data with new bounds - this will update year and data type
            loadDataForYear(currentYear);
        }

        // Calculate approximate area of current view
        function calculateArea(bounds) {
            const [minLat, minLon, maxLat, maxLon] = bounds;
            const latDiff = maxLat - minLat;
            const lonDiff = maxLon - minLon;
            return latDiff * lonDiff;
        }

        // Load data for specific year
        function loadDataForYear(year) {
            console.log('Loading data for year:', year);
            showLoading(true);
            
            // Update slider value to match the year being loaded
            const slider = document.getElementById('year-slider');
            slider.value = year;
            
            // Call backend API for data points
            
            if (currentBounds) {
                const [minLat, minLon, maxLat, maxLon] = currentBounds;
                url = 'http://localhost:5001/instance';
                params = new URLSearchParams({
                    minLat: minLat,
                    minLon: minLon,
                    maxLat: maxLat,
                    maxLon: maxLon,
                    year: year
                });
            } else {
                // Use global bounds if no bounds specified
                url = 'http://localhost:5001/instance';
                params = new URLSearchParams({
                    minLat: -90,
                    minLon: -180,
                    maxLat: 90,
                    maxLon: 180,
                    year: year
                });
            }
            
            const fullUrl = `${url}?${params}`;
            console.log('Fetching URL:', fullUrl);
            console.log('Current bounds:', currentBounds);
            
            fetch(fullUrl)
                .then(response => {
                    console.log('Response status:', response.status);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Data received:', data);
                    // Add year and data_type to match expected format
                    const formattedData = {
                        points: data.points || [],
                        year: year,
                        data_type: year <= 2024 ? 'historical' : 'predicted'
                    };
                    displayData(formattedData);
                    updateUI(formattedData);
                    showLoading(false);
                })
                .catch(error => {
                    console.error('Error loading data:', error);
                    // Show error message to user
                    alert('Error loading data: ' + error.message);
                    showLoading(false);
                });
        }

        // Generate contours from coordinate points
        function generateContoursFromPoints(points) {
            if (!points || points.length === 0) return [];
            
            // Convert points to a simple line contour
            // API returns [lon, lat] tuples, convert to [lat, lon] for Leaflet
            const contourPoints = points.map(point => {
                return [point[1], point[0]]; // Convert [lon, lat] to [lat, lon]
            });
            
            return [{
                level: 'coastline',
                points: contourPoints,
                color: 'red',
                weight: 2
            }];
        }

        // Display data on map
        function displayData(data) {
            // Store current data for toggling
            currentData = data;
            
            // Clear existing layers
            clearLayers();
            
            if (data.points && showContours) {
                // Generate contours from points
                const contours = generateContoursFromPoints(data.points);
                displayContours(contours);
            }
            
            if (data.points && showPoints) {
                displayPoints(data.points);
            }
        }

        // Display contour lines
        function displayContours(contours) {
            contours.forEach(contour => {
                if (contour.points.length > 1) {
                    const polyline = L.polyline(contour.points, {
                        color: contour.color,
                        weight: contour.weight || 2,
                        opacity: 0.8
                    }).addTo(map);
                    
                    polyline.bindPopup(`Coastline: ${contour.level}`);
                    contourLayers.push(polyline);
                }
            });
        }

        // Display individual points
        function displayPoints(points) {
            points.forEach(point => {
                // API returns [lon, lat] tuples
                const lon = point[0];
                const lat = point[1];
                
                const marker = L.circleMarker([lat, lon], {
                    radius: 3,
                    fillColor: 'blue',
                    color: '#000',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.7
                }).addTo(map);
                
                marker.bindPopup(`Coastline Point: ${lat.toFixed(4)}, ${lon.toFixed(4)}`);
                pointLayers.push(marker);
            });
        }


        // Clear all layers
        function clearLayers() {
            contourLayers.forEach(layer => map.removeLayer(layer));
            pointLayers.forEach(layer => map.removeLayer(layer));
            contourLayers = [];
            pointLayers = [];
        }

        // Update UI elements
        function updateUI(data) {
            document.getElementById('current-year').textContent = data.year || currentYear;
            document.getElementById('data-count').textContent = data.points ? data.points.length : 0;
            document.getElementById('data-type').textContent = 
                data.data_type === 'historical' ? 'Historical' : 'Predicted';
        }

        // Show/hide loading indicator
        function showLoading(show) {
            // Don't show loading during animation to prevent flickering
            if (isAnimating) return;
            
            const loading = document.getElementById('loading');
            loading.style.display = show ? 'flex' : 'none';
        }

        // Update button colors based on active state
        function updateButtonColors() {
            const contoursBtn = document.getElementById('toggle-contours');
            const pointsBtn = document.getElementById('toggle-points');
            
            // Remove all color classes
            contoursBtn.classList.remove('active', 'both-active');
            pointsBtn.classList.remove('active', 'both-active');
            
            if (showContours && showPoints) {
                // Both active - green
                contoursBtn.classList.add('both-active');
                pointsBtn.classList.add('both-active');
            } else if (showContours || showPoints) {
                // One active - red
                if (showContours) contoursBtn.classList.add('active');
                if (showPoints) pointsBtn.classList.add('active');
            }
        }

        // Animation functions
        function startAnimation() {
            if (isAnimating) return;
            
            isAnimating = true;
            const animateBtn = document.getElementById('animate-btn');
            animateBtn.textContent = 'Stop Animation';
            animateBtn.classList.add('active');
            

            // added a delay to the animation
            setTimeout(() => {
                // Start from current year and go to 2100
                // currentYear is already set to the slider value, so we don't need to change it
                document.getElementById('year-slider').value = currentYear;
                
                animationInterval = setInterval(() => {
                    if (currentYear >= 2100) {
                        stopAnimation();
                        return;
                    }
                    
                    currentYear++;
                    document.getElementById('year-slider').value = currentYear;
                    document.getElementById('current-year').textContent = currentYear;
                    loadDataForYear(currentYear);
                }, animationSpeed);
            }, animationDelay);
        }

        function stopAnimation() {
            if (!isAnimating) return;
            
            isAnimating = false;
            const animateBtn = document.getElementById('animate-btn');
            animateBtn.textContent = 'Animate';
            animateBtn.classList.remove('active');
            
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }

        function toggleAnimation() {
            if (isAnimating) {
                stopAnimation();
            } else {
                startAnimation();
            }
        }

        // Event listeners
        document.getElementById('year-slider').addEventListener('input', function(e) {
            // Stop animation if user manually changes year
            if (isAnimating) {
                stopAnimation();
            }
            currentYear = parseInt(e.target.value);
            document.getElementById('current-year').textContent = currentYear;
            loadDataForYear(currentYear);
        });

        // Also listen for change event for better compatibility
        document.getElementById('year-slider').addEventListener('change', function(e) {
            // Stop animation if user manually changes year
            if (isAnimating) {
                stopAnimation();
            }
            currentYear = parseInt(e.target.value);
            document.getElementById('current-year').textContent = currentYear;
            loadDataForYear(currentYear);
        });

        // Add mousedown event for immediate feedback
        document.getElementById('year-slider').addEventListener('mousedown', function(e) {
            if (isAnimating) {
                stopAnimation();
            }
        });

        document.getElementById('reset-zoom').addEventListener('click', function() {
            // Stop animation when resetting
            if (isAnimating) {
                stopAnimation();
            }
            map.setView([27.7663, -82.6404], 6);
            currentBounds = null; // Will use global bounds in loadDataForYear
            loadDataForYear(currentYear);
        });

        document.getElementById('animate-btn').addEventListener('click', function() {
            toggleAnimation();
        });

        document.getElementById('toggle-contours').addEventListener('click', function() {
            showContours = !showContours;
            this.classList.toggle('active');
            updateButtonColors();
            // Refresh display with current data
            if (currentData) {
                displayData(currentData);
            }
        });

        document.getElementById('toggle-points').addEventListener('click', function() {
            showPoints = !showPoints;
            this.classList.toggle('active');
            updateButtonColors();
            // Refresh display with current data
            if (currentData) {
                displayData(currentData);
            }
        });

        // Debug function to check slider state
        function debugSlider() {
            const slider = document.getElementById('year-slider');
            const currentYearDisplay = document.getElementById('current-year');
            console.log('Slider value:', slider.value);
            console.log('Current year variable:', currentYear);
            console.log('Display text:', currentYearDisplay.textContent);
            console.log('Slider min/max:', slider.min, slider.max);
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            updateButtonColors(); // Initialize button colors
            
            // Add debug function to window for console access
            window.debugSlider = debugSlider;
        });
    </script>   
</body>
</html>
